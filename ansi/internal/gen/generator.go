package gen

import (
	"fmt"
	"io"
	"sort"
	"strconv"
	"strings"
)

// Generator generates Go code from a specification.
type Generator struct {
	spec      *Spec
	w         io.Writer
	constants map[string]string
}

// NewGenerator creates a new generator.
func NewGenerator(spec *Spec, w io.Writer) *Generator {
	// Expand constants recursively
	constants := make(map[string]string)
	for k, v := range spec.Constants {
		constants[k] = v
	}

	// Resolve constants that reference other constants
	changed := true
	for changed {
		changed = false
		for k, v := range constants {
			newV := v
			for ck, cv := range constants {
				newV = strings.ReplaceAll(newV, ck, cv)
			}
			if newV != v {
				constants[k] = newV
				changed = true
			}
		}
	}

	return &Generator{
		spec:      spec,
		w:         w,
		constants: constants,
	}
}

// Generate writes the generated Go code to the writer.
func (g *Generator) Generate() error {
	// Write package and imports
	if err := g.writeHeader(); err != nil {
		return err
	}

	// Generate each sequence
	for _, seq := range g.spec.Sequences {
		if err := g.generateSequence(seq); err != nil {
			return fmt.Errorf("generating sequence %s: %w", seq.Name, err)
		}
	}

	// Sort modes: ANSI modes first (by number), then DEC modes (by number)
	sortedModes := make([]Mode, len(g.spec.Modes))
	copy(sortedModes, g.spec.Modes)
	sort.Slice(sortedModes, func(i, j int) bool {
		// ANSI modes come before DEC modes
		if sortedModes[i].Type != sortedModes[j].Type {
			return sortedModes[i].Type == "ansi"
		}
		// Within same type, sort by number
		return sortedModes[i].Number < sortedModes[j].Number
	})

	// Generate each mode
	for _, mode := range sortedModes {
		if err := g.generateMode(mode); err != nil {
			return fmt.Errorf("generating mode %s: %w", mode.Name, err)
		}
	}

	return nil
}

func (g *Generator) writeHeader() error {
	header := `// Code generated by internal/gen. DO NOT EDIT.

package ansi

import (
	"fmt"
	"io"
	"strings"
)

`
	_, err := g.w.Write([]byte(header))
	return err
}

func (g *Generator) generateSequence(seq Sequence) error {
	// For sequences with no parameters, generate only constants
	// Users can use io.WriteString(w, ConstantName) directly
	if len(seq.Params) == 0 {
		// Generate main constant
		if err := g.generateConstantSequence(seq.Name, seq, false); err != nil {
			return err
		}

		// Generate alias constants
		for _, alias := range seq.Aliases {
			if err := g.generateConstantSequence(alias, seq, true); err != nil {
				return err
			}
		}
	} else {
		// Generate Write* function
		if err := g.generateWriteFunc(seq.Name, seq, false); err != nil {
			return err
		}

		// Generate Write* functions for aliases
		for _, alias := range seq.Aliases {
			if err := g.generateWriteFunc(alias, seq, true); err != nil {
				return err
			}
		}

		// Generate string function
		if err := g.generateStringFunc(seq.Name, seq, false); err != nil {
			return err
		}

		// Generate string functions for aliases
		for _, alias := range seq.Aliases {
			if err := g.generateStringFunc(alias, seq, true); err != nil {
				return err
			}
		}
	}

	// Generate constants
	for _, constant := range seq.Constants {
		if err := g.generateConstant(seq.Name, constant); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) generateWriteFunc(name string, seq Sequence, isAlias bool) error {
	funcName := "Write" + name

	// Build parameter list
	paramList := "w io.Writer"
	if params := buildParamList(seq.Params); params != "" {
		paramList += ", " + params
	}

	// Write function documentation
	mainFuncName := "Write" + seq.Name
	doc := formatDoc(seq.Doc, funcName, isAlias, mainFuncName)
	if _, err := fmt.Fprintf(g.w, "%s\n", doc); err != nil {
		return err
	}

	// Write function signature
	if _, err := fmt.Fprintf(g.w, "func %s(%s) (int, error) {\n", funcName, paramList); err != nil {
		return err
	}

	// Generate function body
	if err := g.generateWriteFuncBody(seq); err != nil {
		return err
	}

	if _, err := fmt.Fprintf(g.w, "}\n\n"); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateWriteFuncBody(seq Sequence) error {
	// Check if all params have valid defaults and are not strings or bytes
	canOptimize := len(seq.Params) > 0
	for _, param := range seq.Params {
		if param.Type == "string" || param.Type == "byte" || !hasValidDefault(param) {
			canOptimize = false
			break
		}
	}

	if canOptimize {
		conditions := []string{}
		for _, param := range seq.Params {
			defaultVal := formatDefaultValue(param.Default)
			conditions = append(conditions, fmt.Sprintf("%s <= %s", param.Name, defaultVal))
		}

		// Generate the simple case (all params at or below default)
		simpleOutput := g.formatOutput(seq.Format, seq.Params)
		if _, err := fmt.Fprintf(g.w, "\tif %s {\n", strings.Join(conditions, " && ")); err != nil {
			return err
		}
		if _, err := fmt.Fprintf(g.w, "\t\treturn io.WriteString(w, %q)\n", simpleOutput); err != nil {
			return err
		}
		if _, err := fmt.Fprintf(g.w, "\t}\n\n"); err != nil {
			return err
		}
	}

	// Generate conditional logic for each param combination
	if err := g.generateParamCombinations(seq); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateParamCombinations(seq Sequence) error {
	if len(seq.Params) == 0 {
		// No params, just write the format
		output := g.formatOutput(seq.Format, seq.Params)
		_, err := fmt.Fprintf(g.w, "\treturn io.WriteString(w, %q)\n", output)
		return err
	}

	// For single param, simple check
	if len(seq.Params) == 1 {
		param := seq.Params[0]
		// Always include string, byte params, or params without valid defaults
		if param.Type == "string" || param.Type == "byte" || !hasValidDefault(param) {
			formatStr := g.buildFormatString(seq.Format, seq.Params, []bool{false})
			args := g.buildFormatArgs(seq.Params, []bool{false})
			_, err := fmt.Fprintf(g.w, "\treturn fmt.Fprintf(w, %q%s)\n", formatStr, args)
			return err
		}
		// Single int param already handled by the simple case above
		formatStr := g.buildFormatString(seq.Format, seq.Params, []bool{false})
		args := g.buildFormatArgs(seq.Params, []bool{false})
		_, err := fmt.Fprintf(g.w, "\treturn fmt.Fprintf(w, %q%s)\n", formatStr, args)
		return err
	}

	// Multiple params - generate combinations
	return g.generateMultiParamLogic(seq)
}

func (g *Generator) generateMultiParamLogic(seq Sequence) error {
	numParams := len(seq.Params)

	// Check if any params don't have valid defaults - if so, just generate simple code
	canOptimize := true
	for _, param := range seq.Params {
		if param.Type == "string" || param.Type == "byte" || !hasValidDefault(param) {
			canOptimize = false
			break
		}
	}

	if !canOptimize {
		// Just generate simple fmt.Fprintf without conditionals
		formatStr := g.buildFormatString(seq.Format, seq.Params, make([]bool, numParams))
		args := g.buildFormatArgs(seq.Params, make([]bool, numParams))
		_, err := fmt.Fprintf(g.w, "\treturn fmt.Fprintf(w, %q%s)\n", formatStr, args)
		return err
	}

	// Generate if-else chain for different combinations
	// Start with all params included
	for mask := (1 << numParams) - 1; mask > 0; mask-- {
		omitFlags := make([]bool, numParams)
		conditions := []string{}

		for i := 0; i < numParams; i++ {
			if mask&(1<<i) == 0 {
				// This param should be omitted
				omitFlags[i] = true
				defaultVal := formatDefaultValue(seq.Params[i].Default)
				conditions = append(conditions, fmt.Sprintf("%s <= %s", seq.Params[i].Name, defaultVal))
			} else {
				// This param should be included
				omitFlags[i] = false
				defaultVal := formatDefaultValue(seq.Params[i].Default)
				conditions = append(conditions, fmt.Sprintf("%s > %s", seq.Params[i].Name, defaultVal))
			}
		}

		formatStr := g.buildFormatString(seq.Format, seq.Params, omitFlags)
		args := g.buildFormatArgs(seq.Params, omitFlags)

		if mask == (1<<numParams)-1 {
			// First case, use if
			if _, err := fmt.Fprintf(g.w, "\tif %s {\n", strings.Join(conditions, " && ")); err != nil {
				return err
			}
		} else {
			// Subsequent cases, use else if
			if _, err := fmt.Fprintf(g.w, "\t} else if %s {\n", strings.Join(conditions, " && ")); err != nil {
				return err
			}
		}

		if _, err := fmt.Fprintf(g.w, "\t\treturn fmt.Fprintf(w, %q%s)\n", formatStr, args); err != nil {
			return err
		}
	}

	if _, err := fmt.Fprintf(g.w, "\t}\n"); err != nil {
		return err
	}

	// Fallback (shouldn't reach here)
	output := g.formatOutput(seq.Format, seq.Params)
	_, err := fmt.Fprintf(g.w, "\treturn io.WriteString(w, %q)\n", output)
	return err
}

func (g *Generator) buildFormatString(format string, params []Param, omitFlags []bool) string {
	// Expand constants first
	result := g.expandConstants(format)

	// Replace parameter placeholders
	for i, param := range params {
		placeholder := "{" + param.Name + "}"
		if omitFlags[i] {
			// Omit this param
			result = strings.ReplaceAll(result, placeholder, "")
		} else {
			// Include this param
			switch param.Type {
			case "string":
				result = strings.ReplaceAll(result, placeholder, "%s")
			case "byte":
				result = strings.ReplaceAll(result, placeholder, "%c")
			default: // int
				result = strings.ReplaceAll(result, placeholder, "%d")
			}
		}
	}

	// Clean up separators
	result = cleanupSeparators(result)

	return result
}

// cleanupSeparators removes orphaned semicolons (when all adjacent params are omitted)
func cleanupSeparators(s string) string {
	for {
		before := s
		// Remove leading semicolon after bracket
		s = strings.ReplaceAll(s, "[;", "[")
		// Remove trailing semicolon before letter (command char)
		s = strings.ReplaceAll(s, ";H", "H")
		s = strings.ReplaceAll(s, ";A", "A")
		s = strings.ReplaceAll(s, ";B", "B")
		s = strings.ReplaceAll(s, ";C", "C")
		s = strings.ReplaceAll(s, ";D", "D")
		s = strings.ReplaceAll(s, ";E", "E")
		s = strings.ReplaceAll(s, ";F", "F")
		s = strings.ReplaceAll(s, ";G", "G")
		s = strings.ReplaceAll(s, ";I", "I")
		s = strings.ReplaceAll(s, ";X", "X")
		s = strings.ReplaceAll(s, ";Z", "Z")
		s = strings.ReplaceAll(s, ";a", "a")
		s = strings.ReplaceAll(s, ";c", "c")
		s = strings.ReplaceAll(s, ";d", "d")
		s = strings.ReplaceAll(s, ";e", "e")
		s = strings.ReplaceAll(s, ";f", "f")
		s = strings.ReplaceAll(s, ";n", "n")
		s = strings.ReplaceAll(s, ";q", "q")
		// Remove consecutive semicolons
		s = strings.ReplaceAll(s, ";;", ";")
		if s == before {
			break
		}
	}
	return s
}

// buildParamList builds a parameter list string for function signatures.
func buildParamList(params []Param) string {
	var parts []string
	for _, param := range params {
		parts = append(parts, fmt.Sprintf("%s %s", param.Name, param.Type))
	}
	return strings.Join(parts, ", ")
}

// buildParamNames builds a list of parameter names.
func buildParamNames(params []Param) []string {
	var names []string
	for _, param := range params {
		names = append(names, param.Name)
	}
	return names
}

func (g *Generator) buildFormatArgs(params []Param, omitFlags []bool) string {
	args := []string{}
	for i, param := range params {
		if !omitFlags[i] {
			args = append(args, param.Name)
		}
	}

	if len(args) == 0 {
		return ""
	}

	return ", " + strings.Join(args, ", ")
}

func (g *Generator) formatOutput(format string, params []Param) string {
	// Expand constants first
	result := g.expandConstants(format)

	// Remove parameter placeholders
	for _, param := range params {
		placeholder := "{" + param.Name + "}"
		result = strings.ReplaceAll(result, placeholder, "")
	}

	// Clean up separators
	result = cleanupSeparators(result)

	return result
}

func (g *Generator) generateStringFunc(name string, seq Sequence, isAlias bool) error {
	// Build parameter list
	paramList := buildParamList(seq.Params)
	paramNames := buildParamNames(seq.Params)

	// Write function documentation
	doc := formatDoc(seq.Doc, name, isAlias, seq.Name)
	if _, err := fmt.Fprintf(g.w, "%s\n", doc); err != nil {
		return err
	}

	// Write function signature
	if _, err := fmt.Fprintf(g.w, "func %s(%s) string {\n", name, paramList); err != nil {
		return err
	}

	// Write function body
	// For sequences with no parameters, return the constant directly without allocating
	if len(seq.Params) == 0 {
		output := g.formatOutput(seq.Format, seq.Params)
		if _, err := fmt.Fprintf(g.w, "\treturn %q\n", output); err != nil {
			return err
		}
	} else {
		// For sequences with parameters, use strings.Builder
		if _, err := fmt.Fprintf(g.w, "\tvar b strings.Builder\n"); err != nil {
			return err
		}

		args := ", " + strings.Join(paramNames, ", ")
		if _, err := fmt.Fprintf(g.w, "\tWrite%s(&b%s)\n", name, args); err != nil {
			return err
		}

		if _, err := fmt.Fprintf(g.w, "\treturn b.String()\n"); err != nil {
			return err
		}
	}

	if _, err := fmt.Fprintf(g.w, "}\n\n"); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateConstant(seqName string, constant Constant) error {
	// We need to evaluate the constant value at generation time, not as a function call
	// Find the sequence to get its format and params
	var seq *Sequence
	for i := range g.spec.Sequences {
		if g.spec.Sequences[i].Name == seqName {
			seq = &g.spec.Sequences[i]
			break
		}
	}

	if seq == nil {
		return fmt.Errorf("sequence %s not found for constant %s", seqName, constant.Name)
	}

	// Evaluate the constant's value
	output, err := g.evaluateConstant(seq, constant.Args)
	if err != nil {
		return fmt.Errorf("evaluating constant %s: %w", constant.Name, err)
	}

	// Write documentation if present
	if constant.Doc != "" {
		doc := formatConstDoc(constant.Doc, constant.Name)
		if _, err := fmt.Fprintf(g.w, "%s\n", doc); err != nil {
			return err
		}
	}

	// Write constant definition with the literal value
	_, err = fmt.Fprintf(g.w, "const %s = %q\n\n", constant.Name, output)
	return err
}

// evaluateConstant evaluates a constant by substituting args into the format
func (g *Generator) evaluateConstant(seq *Sequence, args []interface{}) (string, error) {
	output := g.expandConstants(seq.Format)

	// Check which parameters should be omitted (when they match defaults)
	omitFlags := make([]bool, len(seq.Params))
	for i, param := range seq.Params {
		if i >= len(args) {
			return "", fmt.Errorf("not enough args (need %d, got %d)", len(seq.Params), len(args))
		}

		// Check if this arg matches the default and should be omitted
		if hasValidDefault(param) {
			switch v := param.Default.(type) {
			case int:
				if argInt, ok := args[i].(int); ok && argInt <= v {
					omitFlags[i] = true
					continue
				}
			case float64:
				if argInt, ok := args[i].(int); ok && argInt <= int(v) {
					omitFlags[i] = true
					continue
				}
			}
		}
	}

	// Replace parameter placeholders with the constant's args
	for i, param := range seq.Params {
		placeholder := "{" + param.Name + "}"

		if omitFlags[i] {
			// Omit this parameter
			output = strings.ReplaceAll(output, placeholder, "")
		} else {
			// Format the arg value based on type
			var argStr string
			switch param.Type {
			case "string":
				argStr = fmt.Sprintf("%v", args[i])
			case "byte":
				argStr = string(byte(args[i].(int)))
			default: // int
				argStr = fmt.Sprintf("%d", args[i])
			}

			output = strings.ReplaceAll(output, placeholder, argStr)
		}
	}

	// Clean up separators
	output = cleanupSeparators(output)

	return output, nil
}

// expandConstants expands constant placeholders in a format string
// expandConstants expands constant placeholders in a format string.
// It splits on spaces, expands each part, then joins without spaces.
// This allows the SP constant to naturally create intentional spaces.
func (g *Generator) expandConstants(format string) string {
	// Split on spaces first
	parts := strings.Split(format, " ")
	var result []string

	for _, part := range parts {
		// Expand constants in this part
		expanded := part
		for i := 0; i < 10; i++ {
			old := expanded
			for k, v := range g.constants {
				expanded = strings.ReplaceAll(expanded, k, v)
			}
			if expanded == old {
				break
			}
		}
		result = append(result, expanded)
	}

	// Join without spaces
	return strings.Join(result, "")
}

func (g *Generator) generateConstantSequence(name string, seq Sequence, isAlias bool) error {
	// Format the output
	output := g.expandConstants(seq.Format)
	output = cleanupSeparators(output)

	// Write documentation
	doc := formatConstantDoc(seq.Doc, name)
	if _, err := fmt.Fprintf(g.w, "%s\n", doc); err != nil {
		return err
	}

	// Write constant definition
	_, err := fmt.Fprintf(g.w, "const %s = %q\n\n", name, output)
	return err
}

func formatConstantDoc(doc, name string) string {
	if doc == "" {
		return fmt.Sprintf("// %s is an ANSI escape sequence.", name)
	}

	lines := strings.Split(strings.TrimSpace(doc), "\n")
	result := []string{}

	// For constants, just state what it is
	result = append(result, fmt.Sprintf("// %s is an ANSI escape sequence.", name))
	result = append(result, "//")

	for _, line := range lines {
		if line == "" {
			result = append(result, "//")
		} else {
			result = append(result, "// "+line)
		}
	}

	return strings.Join(result, "\n")
}

func formatDoc(doc, name string, isAlias bool, mainName string) string {
	if doc == "" {
		return fmt.Sprintf("// %s is an ANSI escape sequence.", name)
	}

	lines := strings.Split(strings.TrimSpace(doc), "\n")
	result := []string{}

	// Add the first line based on function type
	if strings.HasPrefix(name, "Write") {
		result = append(result, fmt.Sprintf("// %s writes the sequence to the writer.", name))
	} else {
		result = append(result, fmt.Sprintf("// %s formats the sequence into a string.", name))
	}

	result = append(result, "//")

	for _, line := range lines {
		if line == "" {
			result = append(result, "//")
		} else {
			result = append(result, "// "+line)
		}
	}

	return strings.Join(result, "\n")
}

// generateMode generates mode constants.
func (g *Generator) generateMode(mode Mode) error {
	// Write documentation
	if mode.Doc != "" {
		lines := strings.Split(strings.TrimSpace(mode.Doc), "\n")
		for _, line := range lines {
			line = strings.TrimSpace(line)
			if line == "" {
				fmt.Fprintf(g.w, "//\n")
			} else {
				fmt.Fprintf(g.w, "// %s\n", line)
			}
		}
	}
	
	// Write const block
	fmt.Fprintf(g.w, "const (\n")
	
	// Write mode constant
	modeType := "ANSIMode"
	if mode.Type == "dec" {
		modeType = "DECMode"
	}
	fmt.Fprintf(g.w, "\tMode%s = %s(%d)\n", mode.Name, modeType, mode.Number)
	
	// Write aliases
	for _, alias := range mode.Aliases {
		fmt.Fprintf(g.w, "\t%s = Mode%s\n", alias, mode.Name)
	}
	
	fmt.Fprintf(g.w, "\n")
	
	// Write Set/Reset/Request constants
	prefix := ""
	if mode.Type == "dec" {
		prefix = "?"
	}
	
	fmt.Fprintf(g.w, "\tSetMode%s = \"\\x1b[%s%dh\"\n", mode.Name, prefix, mode.Number)
	fmt.Fprintf(g.w, "\tResetMode%s = \"\\x1b[%s%dl\"\n", mode.Name, prefix, mode.Number)
	fmt.Fprintf(g.w, "\tRequestMode%s = \"\\x1b[%s%d$p\"\n", mode.Name, prefix, mode.Number)
	
	// Write Set/Reset/Request aliases
	for _, alias := range mode.Aliases {
		fmt.Fprintf(g.w, "\tSetMode%s = SetMode%s\n", alias, mode.Name)
		fmt.Fprintf(g.w, "\tResetMode%s = ResetMode%s\n", alias, mode.Name)
		fmt.Fprintf(g.w, "\tRequestMode%s = RequestMode%s\n", alias, mode.Name)
	}
	
	fmt.Fprintf(g.w, ")\n\n")
	
	return nil
}

func formatConstDoc(doc, name string) string {
	if doc == "" {
		return fmt.Sprintf("// %s is a constant ANSI escape sequence.", name)
	}

	lines := strings.Split(strings.TrimSpace(doc), "\n")
	result := []string{}

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			result = append(result, "//")
		} else {
			result = append(result, "// "+line)
		}
	}

	return strings.Join(result, "\n")
}

func formatDefaultValue(val interface{}) string {
	switch v := val.(type) {
	case int:
		return strconv.Itoa(v)
	case float64:
		return strconv.Itoa(int(v))
	case string:
		return fmt.Sprintf("%q", v)
	default:
		return fmt.Sprintf("%v", v)
	}
}

func hasValidDefault(param Param) bool {
	if param.Default == nil {
		return false
	}
	// Check if it's a negative number
	switch v := param.Default.(type) {
	case int:
		return v >= 0
	case float64:
		return v >= 0
	default:
		return true
	}
}

func formatArgValue(val interface{}) string {
	switch v := val.(type) {
	case int:
		return strconv.Itoa(v)
	case float64:
		return strconv.Itoa(int(v))
	case string:
		return fmt.Sprintf("%q", v)
	default:
		return fmt.Sprintf("%v", v)
	}
}
