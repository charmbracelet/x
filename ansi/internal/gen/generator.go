package gen

import (
	"fmt"
	"io"
	"strconv"
	"strings"
)

// Generator generates Go code from a specification.
type Generator struct {
	spec      *Spec
	w         io.Writer
	constants map[string]string
}

// NewGenerator creates a new generator.
func NewGenerator(spec *Spec, w io.Writer) *Generator {
	// Expand constants recursively
	constants := make(map[string]string)
	for k, v := range spec.Constants {
		constants[k] = v
	}

	// Resolve constants that reference other constants
	changed := true
	for changed {
		changed = false
		for k, v := range constants {
			newV := v
			for ck, cv := range constants {
				newV = strings.ReplaceAll(newV, ck, cv)
			}
			if newV != v {
				constants[k] = newV
				changed = true
			}
		}
	}

	return &Generator{
		spec:      spec,
		w:         w,
		constants: constants,
	}
}

// Generate writes the generated Go code to the writer.
func (g *Generator) Generate() error {
	// Write package and imports
	if err := g.writeHeader(); err != nil {
		return err
	}

	// Generate each sequence
	for _, seq := range g.spec.Sequences {
		if err := g.generateSequence(seq); err != nil {
			return fmt.Errorf("generating sequence %s: %w", seq.Name, err)
		}
	}

	return nil
}

func (g *Generator) writeHeader() error {
	header := `// Code generated by internal/gen. DO NOT EDIT.

package ansi

import (
	"fmt"
	"io"
	"strings"
)

`
	_, err := g.w.Write([]byte(header))
	return err
}

func (g *Generator) generateSequence(seq Sequence) error {
	// Generate Write* function
	if err := g.generateWriteFunc(seq.Name, seq, false); err != nil {
		return err
	}

	// Generate Write* functions for aliases
	for _, alias := range seq.Aliases {
		if err := g.generateWriteFunc(alias, seq, true); err != nil {
			return err
		}
	}

	// Generate string function
	if err := g.generateStringFunc(seq.Name, seq, false); err != nil {
		return err
	}

	// Generate string functions for aliases
	for _, alias := range seq.Aliases {
		if err := g.generateStringFunc(alias, seq, true); err != nil {
			return err
		}
	}

	// Generate constants
	for _, constant := range seq.Constants {
		if err := g.generateConstant(seq.Name, constant); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) generateWriteFunc(name string, seq Sequence, isAlias bool) error {
	funcName := "Write" + name

	// Build parameter list
	paramList := "w io.Writer"
	for _, param := range seq.Params {
		paramList += fmt.Sprintf(", %s %s", param.Name, param.Type)
	}

	// Write function documentation
	mainFuncName := "Write" + seq.Name
	doc := formatDoc(seq.Doc, funcName, isAlias, mainFuncName)
	if _, err := fmt.Fprintf(g.w, "%s\n", doc); err != nil {
		return err
	}

	// Write function signature
	if _, err := fmt.Fprintf(g.w, "func %s(%s) (int, error) {\n", funcName, paramList); err != nil {
		return err
	}

	// Generate function body
	if err := g.generateWriteFuncBody(seq); err != nil {
		return err
	}

	if _, err := fmt.Fprintf(g.w, "}\n\n"); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateWriteFuncBody(seq Sequence) error {
	// Check if all params are at or below default
	// Skip this check for string params
	hasOnlyIntParams := true
	for _, param := range seq.Params {
		if param.Type == "string" {
			hasOnlyIntParams = false
			break
		}
	}

	if len(seq.Params) > 0 && hasOnlyIntParams {
		conditions := []string{}
		for _, param := range seq.Params {
			defaultVal := formatDefaultValue(param.Default)
			conditions = append(conditions, fmt.Sprintf("%s <= %s", param.Name, defaultVal))
		}

		// Generate the simple case (all params at or below default)
		simpleOutput := g.formatOutput(seq.Format, seq.Params, true)
		if _, err := fmt.Fprintf(g.w, "\tif %s {\n", strings.Join(conditions, " && ")); err != nil {
			return err
		}
		if _, err := fmt.Fprintf(g.w, "\t\treturn io.WriteString(w, %q)\n", simpleOutput); err != nil {
			return err
		}
		if _, err := fmt.Fprintf(g.w, "\t}\n\n"); err != nil {
			return err
		}
	}

	// Generate conditional logic for each param combination
	if err := g.generateParamCombinations(seq); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateParamCombinations(seq Sequence) error {
	if len(seq.Params) == 0 {
		// No params, just write the format
		output := g.formatOutput(seq.Format, seq.Params, false)
		_, err := fmt.Fprintf(g.w, "\treturn io.WriteString(w, %q)\n", output)
		return err
	}

	// For single param, simple check
	if len(seq.Params) == 1 {
		param := seq.Params[0]
		if param.Type == "string" {
			// String params are always included
			formatStr := g.buildFormatString(seq.Format, seq.Params, []bool{false})
			args := g.buildFormatArgs(seq.Params, []bool{false})
			_, err := fmt.Fprintf(g.w, "\treturn fmt.Fprintf(w, %q%s)\n", formatStr, args)
			return err
		}
		// Single int param already handled by the simple case above
		formatStr := g.buildFormatString(seq.Format, seq.Params, []bool{false})
		args := g.buildFormatArgs(seq.Params, []bool{false})
		_, err := fmt.Fprintf(g.w, "\treturn fmt.Fprintf(w, %q%s)\n", formatStr, args)
		return err
	}

	// Multiple params - generate combinations
	return g.generateMultiParamLogic(seq)
}

func (g *Generator) generateMultiParamLogic(seq Sequence) error {
	numParams := len(seq.Params)

	// Generate if-else chain for different combinations
	// Start with all params included
	for mask := (1 << numParams) - 1; mask > 0; mask-- {
		omitFlags := make([]bool, numParams)
		conditions := []string{}

		for i := 0; i < numParams; i++ {
			if mask&(1<<i) == 0 {
				// This param should be omitted
				omitFlags[i] = true
				defaultVal := formatDefaultValue(seq.Params[i].Default)
				conditions = append(conditions, fmt.Sprintf("%s <= %s", seq.Params[i].Name, defaultVal))
			} else {
				// This param should be included
				omitFlags[i] = false
				defaultVal := formatDefaultValue(seq.Params[i].Default)
				conditions = append(conditions, fmt.Sprintf("%s > %s", seq.Params[i].Name, defaultVal))
			}
		}

		formatStr := g.buildFormatString(seq.Format, seq.Params, omitFlags)
		args := g.buildFormatArgs(seq.Params, omitFlags)

		if mask == (1<<numParams)-1 {
			// First case, use if
			if _, err := fmt.Fprintf(g.w, "\tif %s {\n", strings.Join(conditions, " && ")); err != nil {
				return err
			}
		} else {
			// Subsequent cases, use else if
			if _, err := fmt.Fprintf(g.w, "\t} else if %s {\n", strings.Join(conditions, " && ")); err != nil {
				return err
			}
		}

		if _, err := fmt.Fprintf(g.w, "\t\treturn fmt.Fprintf(w, %q%s)\n", formatStr, args); err != nil {
			return err
		}
	}

	if _, err := fmt.Fprintf(g.w, "\t}\n"); err != nil {
		return err
	}

	// Fallback (shouldn't reach here)
	output := g.formatOutput(seq.Format, seq.Params, false)
	_, err := fmt.Fprintf(g.w, "\treturn io.WriteString(w, %q)\n", output)
	return err
}

func (g *Generator) buildFormatString(format string, params []Param, omitFlags []bool) string {
	// Expand constants first
	result := format
	for k, v := range g.constants {
		result = strings.ReplaceAll(result, k, v)
	}

	// Replace parameter placeholders
	for i, param := range params {
		placeholder := "{" + param.Name + "}"
		if omitFlags[i] {
			// Omit this param
			result = strings.ReplaceAll(result, placeholder, "")
		} else {
			// Include this param
			if param.Type == "string" {
				result = strings.ReplaceAll(result, placeholder, "%s")
			} else {
				result = strings.ReplaceAll(result, placeholder, "%d")
			}
		}
	}

	// Clean up spacing
	result = strings.ReplaceAll(result, " ; ", ";")
	result = strings.ReplaceAll(result, " ", "")

	return result
}

func (g *Generator) buildFormatArgs(params []Param, omitFlags []bool) string {
	args := []string{}
	for i, param := range params {
		if !omitFlags[i] {
			args = append(args, param.Name)
		}
	}

	if len(args) == 0 {
		return ""
	}

	return ", " + strings.Join(args, ", ")
}

func (g *Generator) formatOutput(format string, params []Param, omitAll bool) string {
	// Expand constants first
	result := format
	for k, v := range g.constants {
		result = strings.ReplaceAll(result, k, v)
	}

	// Remove parameter placeholders
	for _, param := range params {
		placeholder := "{" + param.Name + "}"
		if omitAll {
			result = strings.ReplaceAll(result, placeholder, "")
		} else {
			// This shouldn't be used for params that need values
			result = strings.ReplaceAll(result, placeholder, "")
		}
	}

	// Clean up spacing and separators
	result = strings.ReplaceAll(result, " ; ", "")
	result = strings.ReplaceAll(result, " ", "")

	return result
}

func (g *Generator) generateStringFunc(name string, seq Sequence, isAlias bool) error {
	// Build parameter list
	paramList := ""
	paramNames := []string{}
	for i, param := range seq.Params {
		if i > 0 {
			paramList += ", "
		}
		paramList += fmt.Sprintf("%s %s", param.Name, param.Type)
		paramNames = append(paramNames, param.Name)
	}

	// Write function documentation
	doc := formatDoc(seq.Doc, name, isAlias, seq.Name)
	if _, err := fmt.Fprintf(g.w, "%s\n", doc); err != nil {
		return err
	}

	// Write function signature
	if _, err := fmt.Fprintf(g.w, "func %s(%s) string {\n", name, paramList); err != nil {
		return err
	}

	// Write function body
	if _, err := fmt.Fprintf(g.w, "\tvar b strings.Builder\n"); err != nil {
		return err
	}

	args := ""
	if len(paramNames) > 0 {
		args = ", " + strings.Join(paramNames, ", ")
	}
	if _, err := fmt.Fprintf(g.w, "\tWrite%s(&b%s)\n", name, args); err != nil {
		return err
	}

	if _, err := fmt.Fprintf(g.w, "\treturn b.String()\n"); err != nil {
		return err
	}

	if _, err := fmt.Fprintf(g.w, "}\n\n"); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateConstant(seqName string, constant Constant) error {
	// Build the function call to get the value
	args := []string{}
	for _, arg := range constant.Args {
		args = append(args, formatArgValue(arg))
	}

	funcCall := fmt.Sprintf("%s(%s)", seqName, strings.Join(args, ", "))

	// Write documentation if present
	if constant.Doc != "" {
		doc := formatConstDoc(constant.Doc, constant.Name)
		if _, err := fmt.Fprintf(g.w, "%s\n", doc); err != nil {
			return err
		}
	}

	// Write constant definition
	_, err := fmt.Fprintf(g.w, "var %s = %s\n\n", constant.Name, funcCall)
	return err
}

func formatDoc(doc, name string, isAlias bool, mainName string) string {
	if doc == "" {
		return fmt.Sprintf("// %s is an ANSI escape sequence.", name)
	}

	lines := strings.Split(strings.TrimSpace(doc), "\n")
	result := []string{}
	
	// If this is an alias, add the alias line first
	if isAlias {
		result = append(result, fmt.Sprintf("// %s is an alias for [%s].", name, mainName))
	} else {
		// For main functions, add the appropriate prefix
		if strings.HasPrefix(name, "Write") {
			result = append(result, fmt.Sprintf("// %s formats and writes the sequence to the given writer.", name))
		} else {
			result = append(result, fmt.Sprintf("// %s returns a formatted string for this sequence.", name))
		}
	}
	result = append(result, "//")

	for _, line := range lines {
		if line == "" {
			result = append(result, "//")
		} else {
			result = append(result, "// "+line)
		}
	}

	return strings.Join(result, "\n")
}

func formatConstDoc(doc, name string) string {
	if doc == "" {
		return fmt.Sprintf("// %s is a constant ANSI escape sequence.", name)
	}

	lines := strings.Split(strings.TrimSpace(doc), "\n")
	result := []string{}

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			result = append(result, "//")
		} else {
			result = append(result, "// "+line)
		}
	}

	return strings.Join(result, "\n")
}

func formatDefaultValue(val interface{}) string {
	switch v := val.(type) {
	case int:
		return strconv.Itoa(v)
	case float64:
		return strconv.Itoa(int(v))
	case string:
		return fmt.Sprintf("%q", v)
	default:
		return fmt.Sprintf("%v", v)
	}
}

func formatArgValue(val interface{}) string {
	switch v := val.(type) {
	case int:
		return strconv.Itoa(v)
	case float64:
		return strconv.Itoa(int(v))
	case string:
		return fmt.Sprintf("%q", v)
	default:
		return fmt.Sprintf("%v", v)
	}
}
